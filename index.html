<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
<title>Backgammon</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent;}
body{
  background:#0d0800;min-height:100vh;
  display:flex;flex-direction:column;align-items:center;
  font-family:'Georgia','Times New Roman',serif;
  color:#d4af37;padding:10px 4px 30px;overflow-x:hidden;
}
h1{font-size:16px;font-weight:normal;letter-spacing:8px;text-transform:uppercase;
   margin-bottom:6px;color:#d4af37;text-shadow:0 0 20px rgba(212,175,55,0.5);}
canvas{display:block;width:100%;max-width:440px;height:auto;
       touch-action:none;border:2px solid #3d2510;border-radius:3px;
       box-shadow:0 0 50px rgba(0,0,0,0.95);}
#status{margin-top:8px;font-size:13px;color:#d4af37;text-align:center;
        min-height:40px;letter-spacing:.5px;padding:0 12px;line-height:1.6;}
#btns{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap;justify-content:center;}
button{background:transparent;color:#d4af37;border:1px solid #5a3d18;
       padding:11px 18px;font-family:Georgia,serif;font-size:11px;
       letter-spacing:2px;text-transform:uppercase;cursor:pointer;border-radius:2px;
       transition:background .12s,color .12s;}
button:active,button:focus{outline:none;background:#d4af37;color:#0d0800;}
button:disabled{opacity:.3;pointer-events:none;}
#modal{position:fixed;top:0;left:0;width:100vw;height:100vh;
       background:rgba(13,8,0,0.97);z-index:1000;
       display:flex;align-items:center;justify-content:center;
       backdrop-filter:blur(3px);}
.modal-box{background:#1a1008;border:2px solid #5a3d18;border-radius:6px;
           padding:32px 40px;max-width:420px;text-align:center;
           box-shadow:0 0 60px rgba(212,175,55,0.3);position:relative;}
.modal-close{position:absolute;top:8px;right:12px;background:none;border:none;
             color:#d4af37;font-size:20px;cursor:pointer;opacity:0.6;padding:4px 8px;
             margin:0;letter-spacing:0;}
.modal-close:hover,.modal-close:active{opacity:1;background:none;}
.modal-box h2{font-size:18px;letter-spacing:6px;text-transform:uppercase;
             color:#d4af37;margin-bottom:24px;font-weight:normal;}
.modal-box button{margin:8px 6px;padding:14px 24px;font-size:12px;}
.modal-row{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin-top:16px;}
#cube-display{position:absolute;top:18px;right:18px;background:#1a1008;
              border:2px solid #5a3d18;border-radius:4px;padding:6px 12px;
              font-size:12px;letter-spacing:1px;color:#d4af37;}
</style>
</head>
<body>
<h1>Backgammon</h1>
<canvas id="c"></canvas>
<div id="status">Press New Game to start</div>
<div id="btns">
  <button id="rollBtn"  onclick="rollDice()" disabled>Roll</button>
  <button id="undoBtn"  onclick="undoTurn()"  disabled>Undo Turn</button>
  <button id="passBtn"  onclick="endTurn()"   disabled>End Turn</button>
  <button id="doubleBtn" onclick="offerDouble()" disabled>Double</button>
  <button onclick="newGame()">New Game</button>
</div>
<div id="cube-display" style="display:none;"></div>
<div id="modal" style="display:none;">
  <div class="modal-box" id="modal-content"></div>
</div>
<script>
// â”€â”€ Layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const CW=450, CH=510;
const MX=10, PW=30, BW=30, PH=158, CR=12;
const TOP=8, BOT=TOP+2*PH+28;   // 8 .. 352
const MID_T=TOP+PH, MID_B=MID_T+28;
const BX=MX;
const BAR_X=BX+6*PW;            // 190
const RX=BAR_X+BW+6*PW;         // 400
const BOFF_X=RX+4;               // 404
const DICE_Y=BOT+16;

const COL={
  felt:'#193624',bar:'#3d2210',
  t1:'#7a2828',t2:'#1a4030',
  wh:'#f0ead8',whSh:'#b0aa92',whRim:'#888070',
  bl:'#180e04',blSh:'#382408',blRim:'#6a5018',
  gold:'#d4af37',
  sel:'rgba(255,220,50,0.22)',
  hint:'rgba(60,220,100,0.25)',hDot:'rgba(60,220,100,0.9)',
  bearHL:'rgba(60,220,100,0.3)',
};

// â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let G;      // live game state
let SNAP;   // snapshot taken just after rolling (for undo)
let AI = { enabled: false, color: 'black', difficulty: 'medium' };
let CUBE = { value: 1, owner: null, offered: false };

function cloneState(s){
  return {
    pts: s.pts.map(p=>({...p})),
    bar: {...s.bar},
    off: {...s.off},
    dice: [...s.dice],
    movesLeft: [...s.movesLeft],
    player: s.player,
    phase: s.phase,
    sel: s.sel,
    hints: [...s.hints],
  };
}

function newGame(){
  showModeSelection();
}

function startGame(mode, difficulty, playerColor){
  G={
    pts:Array(24).fill(0).map(()=>({n:0,c:null})),
    bar:{white:0,black:0},
    off:{white:0,black:0},
    dice:[], movesLeft:[],
    player:'white', phase:'roll',
    sel:null, hints:[],
  };
  SNAP=null;
  sp(1,'black',2); sp(6,'white',5); sp(8,'white',3);  sp(12,'black',5);
  sp(13,'white',5);sp(17,'black',3);sp(19,'black',5); sp(24,'white',2);

  CUBE = { value: 1, owner: null, offered: false };

  if(mode === 'ai'){
    AI.enabled = true;
    AI.difficulty = difficulty;
    AI.color = playerColor;
  } else {
    AI.enabled = false;
  }

  syncBtns();
  updateCubeDisplay();
  msg("White's turn â€” Roll the dice");
  draw();

  setTimeout(checkAITurn, 500);
}
function sp(pt,c,n){G.pts[pt-1]={n,c};}
function gp(pt){return G.pts[pt-1];}

// â”€â”€ Modal UI â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function modalCloseBtn(){
  return G ? '<button class="modal-close" onclick="hideModal()">&#x2715;</button>' : '';
}

function showModeSelection(){
  const modal = document.getElementById('modal');
  const content = document.getElementById('modal-content');
  content.innerHTML = `
    ${modalCloseBtn()}
    <h2>New Game</h2>
    <div class="modal-row">
      <button onclick="showDifficultySelection()">vs Computer</button>
      <button onclick="hideModal();startGame('human',null,null);">Two Player</button>
    </div>
  `;
  modal.style.display = 'flex';
}

function showDifficultySelection(){
  const content = document.getElementById('modal-content');
  content.innerHTML = `
    ${modalCloseBtn()}
    <h2>Game Settings</h2>
    <div style="margin:16px 0;font-size:11px;letter-spacing:1px;opacity:0.8;">DIFFICULTY</div>
    <div class="modal-row">
      <button onclick="showColorSelection('easy')">Easy</button>
      <button onclick="showColorSelection('medium')">Medium</button>
      <button onclick="showColorSelection('hard')">Hard</button>
    </div>
  `;
}

function showColorSelection(difficulty){
  const content = document.getElementById('modal-content');
  content.innerHTML = `
    ${modalCloseBtn()}
    <h2>Choose Your Side</h2>
    <div class="modal-row">
      <button onclick="finalizeGame('${difficulty}','white')">Play as White</button>
      <button onclick="finalizeGame('${difficulty}','black')">Play as Black</button>
      <button onclick="finalizeGame('${difficulty}',Math.random()<0.5?'white':'black')">Random</button>
    </div>
  `;
}

function finalizeGame(difficulty, humanColor){
  const aiColor = humanColor === 'white' ? 'black' : 'white';
  hideModal();
  startGame('ai', difficulty, aiColor);
}

function hideModal(){
  document.getElementById('modal').style.display = 'none';
}

// â”€â”€ Coordinates â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function ptX(pt){
  if(pt>=19) return BAR_X+BW+(pt-19)*PW;  // top-right: 19â†’24
  if(pt>=13) return BX+(pt-13)*PW;          // top-left:  13â†’18
  if(pt>=7)  return BX+(12-pt)*PW;          // bot-left:  12â†’7
             return BAR_X+BW+(6-pt)*PW;     // bot-right:  6â†’1
}
function ptCX(pt){return ptX(pt)+PW/2;}
function isTop(pt){return pt>=13;}
function ckY(pt,i){
  return isTop(pt)?TOP+CR+2+i*(CR*2+1):BOT-CR-2-i*(CR*2+1);
}

// â”€â”€ Logic helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function dir(c){return c==='white'?-1:1;}

function allInHome(c){
  if(G.bar[c]>0) return false;
  // white home = 1-6, black home = 19-24
  const lo=c==='white'?1:19, hi=c==='white'?6:24;
  for(let p=1;p<=24;p++)
    if((p<lo||p>hi) && gp(p).c===c && gp(p).n>0) return false;
  return true;
}

function canLand(pt,c){
  const p=gp(pt);
  return !p.c || p.c===c || p.n===1;
}

// Can we bear off from `from` using `die`?
function bearOffOk(from,die,c){
  if(!allInHome(c)) return false;
  const to=from+dir(c)*die;
  if(c==='white'){
    if(to===0) return true;           // exact
    if(to<0){                         // overshoot: no checker on higher pts
      for(let p=from+1;p<=6;p++)
        if(gp(p).c==='white'&&gp(p).n>0) return false;
      return true;
    }
  } else {
    if(to===25) return true;
    if(to>25){
      for(let p=from-1;p>=19;p--)
        if(gp(p).c==='black'&&gp(p).n>0) return false;
      return true;
    }
  }
  return false;
}

// All legal moves from a source (returns array of {from,to,die})
function legalFrom(from){
  const c=G.player;
  const moves=[];
  // Use unique die values to avoid duplicate destination entries,
  // but we still need to find moves for each die separately
  const checked=new Set();
  for(const die of G.movesLeft){
    if(checked.has(die)) continue;
    checked.add(die);
    if(from==='bar'){
      const to=c==='white'?25-die:die;   // white enters on 25-die (pts 24..19), black on die (pts 1..6)
      if(to>=1&&to<=24&&canLand(to,c))
        moves.push({from:'bar',to,die});
    } else {
      const to=from+dir(c)*die;
      if(to>=1&&to<=24&&canLand(to,c)){
        moves.push({from,to,die});
      } else if(bearOffOk(from,die,c)){
        moves.push({from,to:0,die});
      }
    }
  }
  return moves;
}

function anyLegal(){
  const c=G.player;
  if(G.bar[c]>0) return legalFrom('bar').length>0;
  for(let p=1;p<=24;p++)
    if(gp(p).c===c&&gp(p).n>0&&legalFrom(p).length>0) return true;
  return false;
}

function applyMove(mv){
  const c=G.player, opp=c==='white'?'black':'white';
  // Remove from source
  if(mv.from==='bar'){
    G.bar[c]--;
  } else {
    gp(mv.from).n--;
    if(gp(mv.from).n===0) gp(mv.from).c=null;
  }
  // Place on destination
  if(mv.to===0){
    G.off[c]++;
  } else {
    const d=gp(mv.to);
    if(d.c===opp&&d.n===1){   // hit a blot
      d.n=0; d.c=null; G.bar[opp]++;
    }
    d.n++; d.c=c;
  }
  // Consume one instance of this die
  const i=G.movesLeft.indexOf(mv.die);
  G.movesLeft.splice(i,1);
}

// â”€â”€ AI Move Generation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function applyMoveToState(state, move, color){
  const opp = color === 'white' ? 'black' : 'white';
  const newState = cloneState(state);

  // Remove from source
  if(move.from === 'bar'){
    newState.bar[color]--;
  } else {
    newState.pts[move.from-1].n--;
    if(newState.pts[move.from-1].n === 0) newState.pts[move.from-1].c = null;
  }

  // Place on destination
  if(move.to === 0){
    newState.off[color]++;
  } else {
    const d = newState.pts[move.to-1];
    if(d.c === opp && d.n === 1){
      d.n = 0; d.c = null; newState.bar[opp]++;
    }
    d.n++; d.c = color;
  }

  // Consume die
  const i = newState.movesLeft.indexOf(move.die);
  newState.movesLeft.splice(i, 1);

  return newState;
}

function getAllLegalMovesFromState(state, color){
  const moves = [];

  // Check bar first
  if(state.bar[color] > 0){
    const barMoves = legalFromState(state, 'bar', color);
    return barMoves;
  }

  // Check all points
  for(let pt = 1; pt <= 24; pt++){
    const p = state.pts[pt-1];
    if(p.c === color && p.n > 0){
      moves.push(...legalFromState(state, pt, color));
    }
  }

  return moves;
}

function legalFromState(state, from, color){
  const moves = [];
  const checked = new Set();

  for(const die of state.movesLeft){
    if(checked.has(die)) continue;
    checked.add(die);

    if(from === 'bar'){
      const to = color === 'white' ? 25 - die : die;
      if(to >= 1 && to <= 24 && canLandState(state, to, color))
        moves.push({from: 'bar', to, die});
    } else {
      const to = from + dir(color) * die;
      if(to >= 1 && to <= 24 && canLandState(state, to, color)){
        moves.push({from, to, die});
      } else if(bearOffOkState(state, from, die, color)){
        moves.push({from, to: 0, die});
      }
    }
  }

  return moves;
}

function canLandState(state, pt, color){
  const p = state.pts[pt-1];
  return !p.c || p.c === color || p.n === 1;
}

function bearOffOkState(state, from, die, color){
  if(!allInHomeState(state, color)) return false;
  const to = from + dir(color) * die;

  if(color === 'white'){
    if(to === 0) return true;
    if(to < 0){
      for(let p = from + 1; p <= 6; p++)
        if(state.pts[p-1].c === 'white' && state.pts[p-1].n > 0) return false;
      return true;
    }
  } else {
    if(to === 25) return true;
    if(to > 25){
      for(let p = from - 1; p >= 19; p--)
        if(state.pts[p-1].c === 'black' && state.pts[p-1].n > 0) return false;
      return true;
    }
  }
  return false;
}

function allInHomeState(state, color){
  if(state.bar[color] > 0) return false;
  const lo = color === 'white' ? 1 : 19;
  const hi = color === 'white' ? 6 : 24;
  for(let p = 1; p <= 24; p++)
    if((p < lo || p > hi) && state.pts[p-1].c === color && state.pts[p-1].n > 0)
      return false;
  return true;
}

function generateAllTuples(state, color){
  const results = [];
  let maxDiceUsed = 0;

  function recurse(currentState, remainingDice, movesSoFar){
    let foundMove = false;
    const uniqueDice = [...new Set(remainingDice)];

    for(const die of uniqueDice){
      const moves = getAllLegalMovesFromState(currentState, color);
      const movesWithDie = moves.filter(m => m.die === die);

      for(const move of movesWithDie){
        foundMove = true;
        const newState = applyMoveToState(currentState, move, color);
        const newRemaining = [...remainingDice];
        newRemaining.splice(newRemaining.indexOf(die), 1);
        recurse(newState, newRemaining, [...movesSoFar, move]);
      }
    }

    if(!foundMove || remainingDice.length === 0){
      if(movesSoFar.length > maxDiceUsed){
        maxDiceUsed = movesSoFar.length;
        results.length = 0;
        results.push(movesSoFar);
      } else if(movesSoFar.length === maxDiceUsed && movesSoFar.length > 0){
        results.push(movesSoFar);
      }
    }
  }

  recurse(state, state.movesLeft, []);

  // If only 1 die can be used and dice are different, keep only higher die
  if(maxDiceUsed === 1 && state.movesLeft.length === 2 && state.movesLeft[0] !== state.movesLeft[1]){
    const higher = Math.max(state.movesLeft[0], state.movesLeft[1]);
    const higherTuples = results.filter(t => t[0].die === higher);
    if(higherTuples.length > 0){
      return deduplicateTuples(higherTuples, color, state);
    }
  }

  return deduplicateTuples(results, color, state);
}

function deduplicateTuples(tuples, color, baseState){
  const seen = new Set();
  const unique = [];

  for(const tuple of tuples){
    const finalState = applyTupleToState(baseState, tuple, color);
    const hash = hashState(finalState);
    if(!seen.has(hash)){
      seen.add(hash);
      unique.push(tuple);
    }
  }

  return unique;
}

function applyTupleToState(state, tuple, color){
  let s = cloneState(state);
  for(const move of tuple){
    s = applyMoveToState(s, move, color);
  }
  return s;
}

function hashState(state){
  let h = '';
  for(let i = 0; i < 24; i++){
    h += state.pts[i].n + (state.pts[i].c || 'x');
  }
  h += `|w${state.bar.white}b${state.bar.black}|W${state.off.white}B${state.off.black}`;
  return h;
}

// â”€â”€ Position Evaluation â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function pipCount(state, color){
  let sum = 0;
  for(let pt = 1; pt <= 24; pt++){
    const p = state.pts[pt-1];
    if(p.c === color){
      const dist = color === 'white' ? pt : 25 - pt;
      sum += dist * p.n;
    }
  }
  sum += state.bar[color] * 25;
  return sum;
}

function evaluatePosition(state, aiColor){
  const opp = aiColor === 'white' ? 'black' : 'white';
  let score = 0;

  // Pip count advantage
  score += (pipCount(state, opp) - pipCount(state, aiColor)) * 1;

  // Bearing off progress
  score += state.off[aiColor] * 30;
  score -= state.off[opp] * 30;

  // Bar penalty
  score -= state.bar[aiColor] * 25;
  score += state.bar[opp] * 25;

  // Blot exposure
  const myHome = aiColor === 'white' ? [19, 24] : [1, 6];
  const oppHome = aiColor === 'white' ? [1, 6] : [19, 24];

  for(let pt = 1; pt <= 24; pt++){
    const p = state.pts[pt-1];
    if(p.c === aiColor && p.n === 1){
      const inOppHome = pt >= oppHome[0] && pt <= oppHome[1];
      score -= inOppHome ? 15 : 8;
    }
    if(p.c === opp && p.n === 1){
      const inMyHome = pt >= myHome[0] && pt <= myHome[1];
      score += inMyHome ? 15 : 8;
    }
  }

  // Anchors in opponent's home
  const oppHomeRange = aiColor === 'white' ? [1, 6] : [19, 24];
  const goldenPoints = aiColor === 'white' ? [4, 5] : [20, 21];

  for(let pt = oppHomeRange[0]; pt <= oppHomeRange[1]; pt++){
    const p = state.pts[pt-1];
    if(p.c === aiColor && p.n >= 2){
      score += 10;
      if(goldenPoints.includes(pt)) score += 5;
    }
  }

  // Home board strength
  const homeRange = aiColor === 'white' ? [1, 6] : [19, 24];
  for(let pt = homeRange[0]; pt <= homeRange[1]; pt++){
    const p = state.pts[pt-1];
    if(p.c === aiColor && p.n >= 2){
      score += 8;
    }
  }

  // Prime detection
  let primeLen = 0, maxPrime = 0;
  for(let pt = 1; pt <= 24; pt++){
    const p = state.pts[pt-1];
    if(p.c === aiColor && p.n >= 2){
      primeLen++;
      maxPrime = Math.max(maxPrime, primeLen);
    } else {
      primeLen = 0;
    }
  }
  if(maxPrime >= 3) score += maxPrime * 15;
  if(maxPrime >= 6) score += 30;

  // Stack penalty
  for(let pt = 1; pt <= 24; pt++){
    const p = state.pts[pt-1];
    if(p.c === aiColor && p.n > 4){
      score -= (p.n - 4) * 3;
    }
  }

  return score;
}

function winProbability(state, color){
  const score = evaluatePosition(state, color);
  return 1 / (1 + Math.exp(-0.05 * score));
}

// â”€â”€ AI Difficulty Levels â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function aiChooseMove(){
  const tuples = generateAllTuples(cloneState(G), AI.color);
  if(tuples.length === 0) return null;

  switch(AI.difficulty){
    case 'easy': return easyChoice(tuples);
    case 'medium': return mediumChoice(tuples);
    case 'hard': return hardChoice(tuples);
    default: return tuples[0];
  }
}

function easyChoice(tuples){
  // Pick randomly from top 3 evaluated
  const scored = tuples.map(t => ({
    tuple: t,
    score: evaluatePosition(applyTupleToState(G, t, AI.color), AI.color)
  }));
  scored.sort((a, b) => b.score - a.score);
  const topN = scored.slice(0, Math.min(3, scored.length));
  return topN[Math.floor(Math.random() * topN.length)].tuple;
}

function mediumChoice(tuples){
  let bestTuple = tuples[0];
  let bestScore = -Infinity;

  for(const tuple of tuples){
    const resultState = applyTupleToState(G, tuple, AI.color);
    const score = evaluatePosition(resultState, AI.color);
    if(score > bestScore){
      bestScore = score;
      bestTuple = tuple;
    }
  }

  return bestTuple;
}

function hardChoice(tuples){
  return expectiminimax(G, AI.color, tuples);
}

function expectiminimax(state, aiColor, tuples){
  const opp = aiColor === 'white' ? 'black' : 'white';

  if(tuples.length === 0) return null;
  if(tuples.length === 1) return tuples[0];

  // Pre-score and take top 8
  const scored = tuples.map(t => {
    const s = applyTupleToState(state, t, aiColor);
    return { tuple: t, state: s, score: evaluatePosition(s, aiColor) };
  });
  scored.sort((a, b) => b.score - a.score);
  const candidates = scored.slice(0, Math.min(8, scored.length));

  // 21 distinct dice outcomes
  const diceOutcomes = [];
  for(let a = 1; a <= 6; a++)
    for(let b = a; b <= 6; b++)
      diceOutcomes.push({ dice: [a, b], prob: a === b ? 1/36 : 2/36 });

  let bestTuple = candidates[0].tuple;
  let bestExpected = -Infinity;

  for(const cand of candidates){
    let expected = 0;
    for(const outcome of diceOutcomes){
      const oppState = cloneState(cand.state);
      oppState.movesLeft = outcome.dice[0] === outcome.dice[1]
        ? [outcome.dice[0], outcome.dice[0], outcome.dice[0], outcome.dice[0]]
        : [outcome.dice[0], outcome.dice[1]];

      const oppTuples = generateAllTuples(oppState, opp);
      let worstForAI = evaluatePosition(oppState, aiColor);

      for(const ot of oppTuples){
        const resultState = applyTupleToState(oppState, ot, opp);
        const val = evaluatePosition(resultState, aiColor);
        worstForAI = Math.min(worstForAI, val);
      }

      expected += outcome.prob * worstForAI;
    }

    if(expected > bestExpected){
      bestExpected = expected;
      bestTuple = cand.tuple;
    }
  }

  return bestTuple;
}

// â”€â”€ AI Turn Execution â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function checkAITurn(){
  if(!AI.enabled || G.player !== AI.color || G.phase !== 'roll') return;

  // Consider doubling
  if(CUBE.owner === null || CUBE.owner === AI.color){
    const winProb = winProbability(G, AI.color);
    if(winProb >= 0.70 && CUBE.value < 64){
      setTimeout(() => aiOfferDouble(), 600);
      return;
    }
  }

  syncBtns();
  msg('Computer is thinking...');

  setTimeout(() => {
    rollDice(true);
    if(G.phase === 'won') return;
    if(G.phase !== 'move') return;

    const tuple = aiChooseMove();
    if(!tuple || tuple.length === 0){
      return;
    }

    executeAIMoves(tuple, 0);
  }, 800);
}

function executeAIMoves(tuple, index){
  if(index >= tuple.length){
    setTimeout(() => {
      endTurn();
    }, 600);
    return;
  }

  const mv = tuple[index];
  applyMove(mv);
  G.sel = null;
  G.hints = [];

  if(G.off[G.player] === 15){
    msg('Computer wins!');
    G.phase = 'won';
    syncBtns();
    draw();
    return;
  }

  draw();
  setTimeout(() => executeAIMoves(tuple, index + 1), 500);
}

// â”€â”€ Doubling Cube â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateCubeDisplay(){
  const display = document.getElementById('cube-display');
  if(CUBE.value > 1 || CUBE.owner){
    display.style.display = 'block';
    let text = `Cube: ${CUBE.value}`;
    if(CUBE.owner) text += ` (${CUBE.owner})`;
    display.textContent = text;
  } else {
    display.style.display = 'none';
  }
}

function offerDouble(){
  if(G.phase !== 'roll') return;
  if(CUBE.owner !== null && CUBE.owner !== G.player) return;
  if(CUBE.value >= 64) return;
  if(!AI.enabled) return;

  CUBE.value *= 2;
  CUBE.offered = true;
  syncBtns();

  msg(`You doubled to ${CUBE.value}! Computer is deciding...`);

  setTimeout(() => {
    const winProb = winProbability(G, AI.color);
    if(winProb >= 0.25){
      CUBE.owner = AI.color;  // AI accepted, so AI owns the cube
      CUBE.offered = false;
      updateCubeDisplay();
      msg(`Computer accepts! ${cap(G.player)}'s turn â€” Roll the dice`);
      syncBtns();
    } else {
      msg(`Computer declines. You win ${CUBE.value / 2} points!`);
      G.phase = 'won';
      syncBtns();
    }
  }, 1200);
}

function aiOfferDouble(){
  CUBE.value *= 2;
  CUBE.offered = true;

  const modal = document.getElementById('modal');
  const content = document.getElementById('modal-content');
  content.innerHTML = `
    <h2>Computer Doubles!</h2>
    <div style="margin:20px 0;font-size:13px;letter-spacing:1px;">
      The computer offers to double the stakes to ${CUBE.value}.
    </div>
    <div class="modal-row">
      <button onclick="acceptDouble()">Accept</button>
      <button onclick="declineDouble()">Decline</button>
    </div>
  `;
  modal.style.display = 'flex';
}

function acceptDouble(){
  const humanColor = AI.color === 'white' ? 'black' : 'white';
  CUBE.owner = humanColor;  // Human accepted, so human owns the cube
  CUBE.offered = false;
  updateCubeDisplay();
  hideModal();
  checkAITurn();
}

function declineDouble(){
  hideModal();
  msg(`You declined. Computer wins ${CUBE.value / 2} points!`);
  G.phase = 'won';
  syncBtns();
}

// â”€â”€ Game actions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function rollDice(_internal){
  if(G.phase!=='roll') return;
  if(!_internal && AI.enabled && G.player === AI.color) return;

  const a=r6(),b=r6();
  G.dice=a===b?[a,a,a,a]:[a,b];
  G.movesLeft=a===b?[a,a,a,a]:[a,b];
  G.phase='move';
  G.sel=null; G.hints=[];
  // Save snapshot for undo
  SNAP=cloneState(G);
  syncBtns();
  if(!anyLegal()){
    msg(`${cap(G.player)} rolled ${diceStr()} â€” No legal moves!`);
    const isAI = AI.enabled && G.player === AI.color;
    setTimeout(endTurn, isAI ? 800 : 1400);
  } else {
    msg(`${cap(G.player)} rolled ${diceStr()} â€” Tap a checker to move`);
  }
  draw();
}
function r6(){return Math.floor(Math.random()*6)+1;}
function diceStr(){return G.dice.length===4?G.dice[0]+' & '+G.dice[1]+' (doubles!)':G.dice.join(' & ');}

function endTurn(){
  G.sel=null; G.hints=[];
  G.movesLeft=[]; G.dice=[];
  G.player=G.player==='white'?'black':'white';
  G.phase='roll'; SNAP=null;
  syncBtns();
  msg(`${cap(G.player)}'s turn â€” Roll the dice`);
  draw();

  setTimeout(checkAITurn, 300);
}

function undoTurn(){
  if(!SNAP) return;
  G=cloneState(SNAP);
  syncBtns();
  msg(`${cap(G.player)} rolled ${diceStr()} â€” Tap a checker to move`);
  draw();
}

// â”€â”€ Interaction â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const canvas=document.getElementById('c');
canvas.addEventListener('pointerdown',onTap);

function onTap(e){
  if(AI.enabled && G.player === AI.color) return; // Block interaction during AI turn
  if(G.phase!=='move'&&G.phase!=='nomoves') return;
  if(G.phase==='nomoves') return;
  e.preventDefault();
  const r=canvas.getBoundingClientRect();
  const x=(e.clientX-r.left)*(CW/r.width);
  const y=(e.clientY-r.top)*(CH/r.height);
  const tgt=hitTest(x,y);
  const c=G.player;

  if(G.sel!==null){
    // Try to execute move to tapped target
    const movs=legalFrom(G.sel);
    const mv=movs.find(m=>m.to===tgt);
    if(mv){
      executeMove(mv); return;
    }
    // Tap on own checker â†’ re-select
    if(isOwn(tgt,c)){
      selectFrom(tgt); draw(); return;
    }
    // Tap elsewhere â†’ deselect
    G.sel=null; G.hints=[]; draw(); return;
  }

  // Select a checker
  if(isOwn(tgt,c)){
    selectFrom(tgt); draw();
  }
}

function executeMove(mv){
  applyMove(mv);
  G.sel=null; G.hints=[];

  // Win check
  if(G.off[G.player]===15){
    msg(`ðŸ† ${cap(G.player)} wins! Press New Game.`);
    G.phase='won'; syncBtns(); draw(); return;
  }

  // More moves?
  if(G.movesLeft.length>0&&anyLegal()){
    msg(`${cap(G.player)}: Tap a checker (${G.movesLeft.join(', ')} left)`);
    syncBtns(); draw(); return;
  }

  // No more moves this turn
  if(G.movesLeft.length>0){
    msg(`${cap(G.player)}: No more legal moves. End your turn.`);
  } else {
    msg(`${cap(G.player)}: All moves used. End your turn.`);
  }
  G.phase='nomoves'; syncBtns(); draw();
}

function isOwn(tgt,c){
  if(tgt==='bar') return G.bar[c]>0;
  if(typeof tgt==='number'&&tgt>=1&&tgt<=24) return gp(tgt).c===c&&gp(tgt).n>0;
  return false;
}

function selectFrom(src){
  // Must move from bar if checkers are there
  if(G.bar[G.player]>0&&src!=='bar') return;
  const movs=legalFrom(src);
  if(movs.length===0) return;  // no legal moves from here, don't select
  G.sel=src;
  G.hints=[...new Set(movs.map(m=>m.to))];
}

function hitTest(x,y){
  if(y<TOP||y>BOT) return null;
  if(x>=BAR_X&&x<BAR_X+BW) return 'bar';
  if(x>=BOFF_X) return 0;

  const inTop = y < (MID_T+MID_B)/2;

  if(x>=BAR_X+BW){
    // Right side of bar: top = pts 19-24, bottom = pts 6-1
    const col=Math.max(0,Math.min(5,Math.floor((x-(BAR_X+BW))/PW)));
    return inTop ? 19+col : 6-col;
  } else if(x>=BX){
    // Left side of bar: top = pts 13-18, bottom = pts 12-7
    const col=Math.max(0,Math.min(5,Math.floor((x-BX)/PW)));
    return inTop ? 13+col : 12-col;
  }
  return null;
}

// â”€â”€ Rendering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
canvas.width=CW; canvas.height=CH;
const ctx=canvas.getContext('2d');

function draw(){
  ctx.clearRect(0,0,CW,CH);
  drawBoard();
  drawCheckers();
  drawDice();
}

function drawBoard(){
  ctx.fillStyle='#0d0800';
  ctx.fillRect(0,0,CW,CH);

  ctx.fillStyle=COL.felt;
  ctx.fillRect(BX,TOP,RX-BX,BOT-TOP);

  for(let pt=1;pt<=24;pt++) drawTri(ptX(pt),pt);

  ctx.fillStyle=COL.bar;
  ctx.fillRect(BX,MID_T,RX-BX,MID_B-MID_T);
  ctx.fillRect(BAR_X,TOP,BW,BOT-TOP);

  ctx.fillStyle='#150a01';
  ctx.fillRect(BOFF_X,TOP,CW-BOFF_X,BOT-TOP);
  ctx.fillStyle='#3a2210'; ctx.font='8px Georgia'; ctx.textAlign='center';
  ctx.fillText('BEAR',(BOFF_X+CW)/2,TOP+PH-4);
  ctx.fillText('OFF', (BOFF_X+CW)/2,TOP+PH+8);

  // Selection highlight
  if(G.sel==='bar'){
    ctx.fillStyle=COL.sel; ctx.fillRect(BAR_X,TOP,BW,BOT-TOP);
  } else if(G.sel>=1&&G.sel<=24){
    ctx.fillStyle=COL.sel;
    const sx=ptX(G.sel);
    isTop(G.sel)?ctx.fillRect(sx,TOP,PW,PH):ctx.fillRect(sx,BOT-PH,PW,PH);
  }

  // Hint highlights
  for(const h of G.hints){
    if(h===0){
      ctx.fillStyle=COL.bearHL;
      ctx.fillRect(BOFF_X,TOP,CW-BOFF_X,BOT-TOP);
    } else {
      const hx=ptX(h);
      ctx.fillStyle=COL.hint;
      isTop(h)?ctx.fillRect(hx,TOP,PW,PH):ctx.fillRect(hx,BOT-PH,PW,PH);
      ctx.fillStyle=COL.hDot; ctx.beginPath();
      isTop(h)?ctx.arc(ptCX(h),TOP+PH-18,6,0,Math.PI*2)
             :ctx.arc(ptCX(h),BOT-PH+18,6,0,Math.PI*2);
      ctx.fill();
    }
  }

  ctx.strokeStyle='#4a2d10'; ctx.lineWidth=1.5;
  ctx.strokeRect(BX,TOP,RX-BX,BOT-TOP);
  ctx.strokeStyle='#3a2010'; ctx.lineWidth=1;
  ctx.beginPath();ctx.moveTo(BOFF_X,TOP);ctx.lineTo(BOFF_X,BOT);ctx.stroke();

  ctx.fillStyle='rgba(212,175,55,0.28)'; ctx.font='8px Georgia'; ctx.textAlign='center';
  for(let pt=1;pt<=24;pt++){
    isTop(pt)?ctx.fillText(pt,ptCX(pt),MID_T-4)
             :ctx.fillText(pt,ptCX(pt),MID_B+10);
  }

  drawBearOff();
}

function drawTri(x,pt){
  ctx.fillStyle=pt%2===0?COL.t1:COL.t2;
  ctx.beginPath();
  isTop(pt)?(ctx.moveTo(x,TOP),ctx.lineTo(x+PW,TOP),ctx.lineTo(x+PW/2,TOP+PH))
           :(ctx.moveTo(x,BOT),ctx.lineTo(x+PW,BOT),ctx.lineTo(x+PW/2,BOT-PH));
  ctx.closePath(); ctx.fill();
}

function drawChecker(cx,cy,col,lbl){
  const w=col==='white';
  ctx.beginPath();ctx.arc(cx,cy+1,CR+1,0,Math.PI*2);
  ctx.fillStyle='rgba(0,0,0,0.45)';ctx.fill();
  const g=ctx.createRadialGradient(cx-3,cy-3,1,cx,cy,CR);
  w?(g.addColorStop(0,'#fff8e8'),g.addColorStop(1,'#ccc0a0'))
   :(g.addColorStop(0,'#3a2810'),g.addColorStop(1,'#0e0800'));
  ctx.beginPath();ctx.arc(cx,cy,CR,0,Math.PI*2);
  ctx.fillStyle=g;ctx.fill();
  ctx.strokeStyle=w?COL.whRim:COL.blRim;ctx.lineWidth=2;ctx.stroke();
  ctx.beginPath();ctx.arc(cx,cy,CR-4,0,Math.PI*2);
  ctx.strokeStyle=w?COL.whSh:COL.blSh;ctx.lineWidth=1;ctx.stroke();
  if(lbl){
    ctx.fillStyle=w?'#3a3020':'#c8a040';
    ctx.font='bold 10px Georgia';ctx.textAlign='center';ctx.textBaseline='middle';
    ctx.fillText(lbl,cx,cy);ctx.textBaseline='alphabetic';
  }
}

function drawCheckers(){
  for(let pt=1;pt<=24;pt++){
    const p=gp(pt); if(!p.n) continue;
    const show=Math.min(p.n,5);
    for(let i=0;i<show;i++)
      drawChecker(ptCX(pt),ckY(pt,i),p.c,i===0&&p.n>1?p.n:null);
  }
  const bcx=BAR_X+BW/2;
  for(let i=0;i<Math.min(G.bar.white,5);i++)
    drawChecker(bcx,MID_B-CR-i*(CR*2+1),'white',i===0&&G.bar.white>1?G.bar.white:null);
  for(let i=0;i<Math.min(G.bar.black,5);i++)
    drawChecker(bcx,MID_T+CR+i*(CR*2+1),'black',i===0&&G.bar.black>1?G.bar.black:null);
}

function drawBearOff(){
  const cx=(BOFF_X+CW)/2;
  for(let i=0;i<G.off.white;i++){
    ctx.beginPath();ctx.arc(cx,BOT-6-i*5,3.5,0,Math.PI*2);
    ctx.fillStyle='rgba(240,232,210,0.8)';ctx.fill();
  }
  for(let i=0;i<G.off.black;i++){
    ctx.beginPath();ctx.arc(cx,TOP+6+i*5,3.5,0,Math.PI*2);
    ctx.fillStyle='rgba(30,15,4,0.9)';ctx.fill();
    ctx.strokeStyle='#5a4010';ctx.lineWidth=0.8;ctx.stroke();
  }
  ctx.textAlign='center';ctx.font='10px Georgia';
  if(G.off.white){ctx.fillStyle='rgba(212,175,55,0.55)';ctx.fillText(G.off.white,cx,BOT-G.off.white*5-12);}
  if(G.off.black){ctx.fillStyle='rgba(212,175,55,0.55)';ctx.fillText(G.off.black,cx,TOP+G.off.black*5+18);}
}

const PIP={
  1:[[.5,.5]],2:[[.28,.28],[.72,.72]],3:[[.28,.28],[.5,.5],[.72,.72]],
  4:[[.28,.28],[.72,.28],[.28,.72],[.72,.72]],
  5:[[.28,.28],[.72,.28],[.5,.5],[.28,.72],[.72,.72]],
  6:[[.28,.22],[.72,.22],[.28,.5],[.72,.5],[.28,.78],[.72,.78]],
};
function rr(x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y);ctx.lineTo(x+w-r,y);ctx.arcTo(x+w,y,x+w,y+r,r);
  ctx.lineTo(x+w,y+h-r);ctx.arcTo(x+w,y+h,x+w-r,y+h,r);
  ctx.lineTo(x+r,y+h);ctx.arcTo(x,y+h,x,y+h-r,r);
  ctx.lineTo(x,y+r);ctx.arcTo(x,y,x+r,y,r);ctx.closePath();
}

function drawDice(){
  if(!G.dice.length) return;
  const sz=34,gap=8,n=G.dice.length;
  const sx=CW/2-(n*(sz+gap)-gap)/2;
  const used=n-G.movesLeft.length;
  const w=G.player==='white';
  for(let i=0;i<n;i++){
    const isUsed=i<used;
    const dx=sx+i*(sz+gap);
    rr(dx,DICE_Y,sz,sz,5);
    ctx.fillStyle=isUsed?'#181006':(w?'#f0ece0':'#18100a');
    ctx.fill();
    ctx.strokeStyle=isUsed?'#2a1a06':COL.gold;
    ctx.lineWidth=isUsed?0.8:1.5; ctx.stroke();
    ctx.fillStyle=isUsed?'#2a2010':(w?'#18100a':COL.gold);
    for(const[px,py] of PIP[G.dice[i]]){
      ctx.beginPath();ctx.arc(dx+px*sz,DICE_Y+py*sz,2.8,0,Math.PI*2);ctx.fill();
    }
  }
}

// â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function msg(s){document.getElementById('status').textContent=s;}
function cap(s){return s[0].toUpperCase()+s.slice(1);}
function syncBtns(){
  if(!G){
    document.getElementById('rollBtn').disabled=true;
    document.getElementById('undoBtn').disabled=true;
    document.getElementById('passBtn').disabled=true;
    document.getElementById('doubleBtn').disabled=true;
    return;
  }
  const isAITurn = AI.enabled && G.player === AI.color;
  const inMove=G.phase==='move'||G.phase==='nomoves';

  document.getElementById('rollBtn').disabled=G.phase!=='roll' || isAITurn;
  document.getElementById('undoBtn').disabled=!SNAP||G.phase==='won'||isAITurn;
  document.getElementById('passBtn').disabled=G.phase!=='nomoves'||isAITurn;

  const canDouble = AI.enabled && G.phase === 'roll' && !isAITurn
                    && (CUBE.owner === null || CUBE.owner === G.player)
                    && CUBE.value < 64;
  document.getElementById('doubleBtn').disabled=!canDouble;
}
</script>
</body>
</html>
